use std::io;            // Rust standard library
use rand::Rng;          // Defines methods that are required for random number generation
use std::cmp::Ordering; // Contains the enums Less, Greater, Equal

fn main() {
    println!("Guess the number.");

    let secret_number = rand::thread_rng().gen_range(1..=10); // Random number between 1 and 10 inclusive
    /*
    The default data type is i32,
        but since we are comparing to guess, which is a u32, Rust infers that secret_number should be a u32.
        (The greyed out stuff from rust-analyzer is what Rust implies)

    thread_rng gives us a random number generator based on a seed generated by the os.
    .gen_range generates a random number with the random number generator.
    */
    
    loop {
        println!("Enter your guess:");

        let mut guess = String::new(); // Variables are immutable by default

        io::stdin()
            .read_line(&mut guess) // Appends the input to the buffer, which must be mutable
            .expect("Failed to read line."); // Returns the line read, or crashes if there is an error
        /*
        NOTE: The indentation is for readability. The statement does not end until there is a semicolon.
        The above statement is equivalent to:
            io::stdin().readline(&mut guess).expect("Failed to read line.");
        */

        let guess: u32 = match guess.trim().parse() {
            Ok(number) => number,
            Err(_) => continue, // _ is a catch for all errors, continue goes to the next iteration of the loop
        };
        /*
        This is not creating a new variable, but reusing guess with "shadowing"
        .trim is like .strip from python. It is needed to trim \n from .read_line
        .parse converts the String to another type, returning Ok if it is able, Err if it isn't 
        */

        println!("You guessed: {}", guess); // Similar to old-school python string formatting
        /* 
        Can also be written with guess inside the {} because we are not performing any operations to guess
        */

        match guess.cmp(&secret_number) { // Returns Ordering based on the comparison of guess and secret_number
            // Arms of the match expression match the result of .cmp to these Ordering condition
            Ordering::Less => println!("You guessed too little."),
            Ordering::Greater => println!("You guessed too much."),
            Ordering::Equal => {
                println!("You guessed the right number.");
                break; // Breaks out of the loop, which is the last part of this program
            }
        }
    }
}
